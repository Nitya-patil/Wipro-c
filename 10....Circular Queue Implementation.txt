Circular Queue Implementation
Description:
Implement a circular queue using an array. The queue should support enqueue, dequeue, and frontÂ operations.


#include <iostream>
#include <stdexcept>

class CircularQueue {
private:
    int *queue;
    int front;
    int rear;
    int size;
    int capacity;

public:
    // Constructor to initialize the queue with a given capacity
    CircularQueue(int cap) : front(0), rear(0), size(0), capacity(cap) {
        queue = new int[capacity];
    }

    // Destructor to clean up the dynamically allocated array
    ~CircularQueue() {
        delete[] queue;
    }

    // Enqueue an element to the queue
    void enqueue(int value) {
        if (isFull()) {
            throw std::overflow_error("Queue is full");
        }
        queue[rear] = value;
        rear = (rear + 1) % capacity;
        size++;
    }

    // Dequeue an element from the queue
    void dequeue() {
        if (isEmpty()) {
            throw std::underflow_error("Queue is empty");
        }
        front = (front + 1) % capacity;
        size--;
    }

    // Get the front element of the queue
    int frontElement() const {
        if (isEmpty()) {
            throw std::underflow_error("Queue is empty");
        }
        return queue[front];
    }

    // Check if the queue is empty
    bool isEmpty() const {
        return size == 0;
    }

    // Check if the queue is full
    bool isFull() const {
        return size == capacity;
    }
};

int main() {
    CircularQueue cq(5);

    cq.enqueue(1);
    cq.enqueue(2);
    cq.enqueue(3);
    cq.enqueue(4);
    cq.enqueue(5);

    try {
        cq.enqueue(6); // This should throw an overflow error
    } catch (const std::overflow_error& e) {
        std::cout << e.what() << std::endl;
    }

    std::cout << "Front element: " << cq.frontElement() << std::endl; // Output: 1

    cq.dequeue();
    std::cout << "Front element after one dequeue: " << cq.frontElement() << std::endl; // Output: 2

    cq.dequeue();
    cq.enqueue(6);
    std::cout << "Front element after enqueue 6: " << cq.frontElement() << std::endl; // Output: 3

    return 0;
}
